... dive a bit deeper into how can you build privacy-preserving applications on top of StarkNet, on the custom Zcash fork that we created. And this fork is different from the canonical Z- Zcash Mainnet. Important to note, like why, right? So like, why [laughs]- 

Okay 

... did we bother to do all, all, all the, all the things? 'Cause StarkNet is essentially a roll-up on top of Zcash. 

You know, quite spoken about was this ZK passport from Aztec. I think that's more of the stateless one. 

There's also an explorer, uh, for, uh, StarkNet's. You can use to check the status of, of your transaction and the proof is, is, is verified correctly. All right. 

This is on testnet, right? And what exactly does this mean to the Zcash community, and how far is this from being possible on actually becoming the actual roll-up on top of Zcash? I've got a tricky question. 

Sure. 

I mean, feel free to skip as well, but what do you think goes through... W- what do you think would go through first? Do you think it's OPRCAT or the opSTARK-verify passing through, uh, on the Bitcoin side first, or is this the 

... 

... STEEZY, uh, going through first? What do you think? [laughs] Hey, everyone. This is Aakash here. Uh, before we jump into the workshop, I just wanna let you guys know that we have now bumped up the prize pool for the StarkNet track on Zephyr Funk Hackathon from $10,000 to $35,000. And alongside, we've also got a referral program where anyone who refers a team to the StarkNet track, and if the team wins top three, the referrer would receive $1,000 per team. And the prize pool for this is about $3,000. We've attached all the links down in the text tweet. Check it out, and now let's jump to the workshop. GM, GM everyone. Welcome to the StarkNet workshop, uh, where we'll be covering everything about StarkNet, what does this unlock, a quick l- high-level architecture, also few app. We'll also be mentioning about the dApps that we're l- really looking forward to be built on this particular Zephyr Hackathon. So yeah, uh, firstly, we have Michael joining us. Uh, Michael is the exploration engineer from StarkWare. I'd love for him to, uh, talk more about himself and about the projects that he's been working on. I think it's pretty cool on what he's been doing currently. Michael, welcome to the, uh, workshop. 

Thank you, thank you. Glad to be here. 

Okay. 

All right. So today we will be talking about two things. So first, about StarkNet, what is it and how to pronounce it correctly. 

[laughs] 

And secondly, so I will dive a bit deeper into how can you build privacy-preserving application on top of the StarkNet, and we're going to use Cairo and Noir, and then many other interesting things that I will expand on a little bit later. 

Awesome. Sounds good. Uh, I think Michael has already prepared a whole slideshow in terms of explain, uh, explaining everything about StarkNet. I think, Michael, feel free to take it off. 

Of course, of course. Let me, let me do that. And now. All right. So what is StarkNet? Like first of all, h- like how to pronounce it. So the answer this is there is no correct answer, so whatever you like. So someone says Z StarkNet, someone says zStarkNet, like, like whatever works for you. So in a nutshell, a StarkNet is the StarkNet chain that sells on Zcash. How does it work right now is we have a custom StarkNet chain that runs using the Modaro sequencer, so this is operated by the Cardinal team. And so this is, this is a single, centralized sequencer set up where we produce blocks, and then we, um, prove the execution using these two prover. But you obtain a single system proof that we can later verify on the custom Zcash fork that we created. And this fork, uh, is different from the canonical Z- Zcash Mainnet in a sense that it enables something that is called TZE, or transparent Zcash extension, which is basically just the new types of inputs and outputs you can have in your transaction, where instead of a Bitcoin script you have an, uh, special and shrine program whose goal is to basically verify proofs and maintain the chain state. So that's basically the stack. The important thing to know about StarkNet, it is essentially compatible with StarkNets, like almost. So there are, like, some features, just, like, so- some of the existing tooling and SDKs might not work as you expect. But mostly you can... If you have an application that runs on StarkNet, you can also run it on StarkNet without any major issues. Yeah, I think that's, that's pretty much the overview. Aakash, if you have any specific questions that we can expand on them. 

Yeah, uh, yeah, I mean, uh, I think, uh, you have few se- uh, next set of slides that covers this. I'll probably wait for those. 

Of course. 

Yeah. 

All right. Important note, like why, right? So like why [laughs)- 

Okay 

... did we bother to do all, all, all the, all the things? The idea of StarkNet is that, uh... I mean, Zcash is great. So this is the, um, encrypted Bitcoin, so it allows you to store your funds in a shielded pool with a huge... Like, now it's already a huge anonymity set. And, yeah, do not dox yourself. Now, if you wanted to do something more interesting than just storing your funds in, in a secure manner, you need two things. You need programmability and you need scale. And in terms of the programmability, Zcash is limited by the Bitcoin script. Moreover, it's not the same Bitcoin script that we have in, in Bitcoin, but it's actually an older version that doesn't have all, like even the functionality that is, uh, currently available on Bitcoin. Another option is the one I mentioned, the transparent Zcash extension. But this is, again, it's not the part of the main chain, the current protocol, so it has to be adopted by, uh, by Zcash community and implemented in the con- in the, uh, Zebra and, uh, Rust, Rust nodes. So what is the plan then, right? So how do we enable scale and programmability on top of Zcash? So the, the answer is that, is the, like, what we have been doing for the past five years, right? So and this is the layer twos.... and in particular, roll-ups. And StarkNet is essentially a roll-up on top of Zcash, uh, and, uh, not just a roll-up, but the, uh, StarkNet roll-up, uh, which means that 

it's, uh, it comes with the really high throughput, uh, uh, ZK tech that, uh, can aggregate multiple, uh, operations in a really, really fast manner. And, uh, also it comes within already established ecosystem of applications and tooling and SDKs and everything that we can leverage and provide 

Mm-hmm. 

... probability and scale for Zcash. And, uh, StarkNet is then- is the, uh, proof of concept that has to show, like has to- has to demonstrate that this can work. Uh, like this is how much does, uh, does it cost, and this is what it enables. And so part of our goal, uh, in- in the scope of- of the hackathon is to, uh, bring, uh, more use cases on the StarkNet to showcase, um, what can be built, right, and how can- can we leverage all this vertical 

to 

build truly privacy-preserving applications. Okay, uh, that's all for- for StarkNet for now. Now, I'm going to talk more about what is I mean when- when I say privacy-preserving applications, and how exactly we're gonna to build them on StarkNet. So very high level, when we talk about a privacy app, there are typically two parts. So one part is the one that is running on the client side in, like either in your browser or- or in the mobile application. And the other part is the on-chain part, which is typically implemented as a smart contract, and those two parts do interact. Frequently, we will refer to this part as the, um, ZK circuit. Uh, this is the part that we 

execute and generate proof for on the clients. And the- the on-chain part will be a smart contract or verifier. This is where we will- we will, uh, check the proofs that we generate on the clients, and also where we- we are gonna to keep our state. Okay, so now I mentioned the state, and, uh, this is one of the, I think, like probably most challenging thing when you're building a privacy app, uh, because there are like many pitfalls. Also, uh, in some complex cases, we are required to do some heavy engineering to do this properly. In a nutshell, so when we are building a privacy app, obviously, uh, 

we- we cannot expose any information to, uh, in public, right? And- and if we need some data to be stored on-chain, it has to be encrypted. Okay? So whenever you have a state that you have to- have to be... 

It has to be, um, stored, uh, on-chain, it has to be encrypted. What does it mean? It means that on the clients, you have to encrypt and decrypt your state, which implies that you also have to do key management, which also implies that you have to decrypt your state. And typically, it's not just the, you know, like one or two variables that you have to decrypt. You have to index the entire or part of chain that is specific to your application, and then do maybe like more smart decryption or more straightforward trial decryption in order to get all the data required for your application to function correctly. So there are also types of apps that are more stateless, so the apps that do not require you to keep any part of your state on-chain in an encrypted form. Some examples of the- those apps includes 

ZK passport. You probably heard of that, right? So it's when you scan the chip that is- uh, that is kept in your passport in order to generate the proof that you are over 18 or you're resident in a specific country, and so on and so on. In that case, you do not keep any data encrypted on-chain. In fact, so if, like it's kind of by design that you do not do that. But still, you have to keep some sort of, uh, digest of what you're doing with your data in order to prevent reusing your artist like claims, things like that. In those cases, instead of keeping your state on-chain, you just keep state commitments or just hash digest of your states. Sometimes those things are called nullifiers because they kind of nullif- uh, nullified your previous state. And this is kind of like before, this is a lightfa- lightweight form of state management that has to be done on-chain. Um, to kind of wrap this up, when you're building a privacy app, so typically, it's either stateful, right, when you have some notion of encrypted data that- that- that is kept on-chain, or it's more or less stateless where you just generate some client side proofs and then verify them on-chain, marking that specific verification is done and cannot be reduced multiple times. 

I think also one of- one of the recent, uh, the recent stuff that's been, uh, you know, quite spoken about was this ZK passport from Aztec. I think that's more of the stateless one. 

Yeah. Exactly, exactly. Yeah, the- this is the good example. And like silly little, a little bit later is- is when you're building on- on StarkNets, for instance, compared to Aztec, we- you are not... So we do not provide the rich state model like framework that hides this sort of complexity from the developer. So you kind of have to go low level and do essentially like d- design the state model, tailor for your app. So this has both advantages and disadvantages. So on- on the one hand, if you do simple things, for instance, ZK passport, I mean, it's not simple, but like from the states...... standpoint, it's like it's simple-ish. You're good because you can do this in a, in a simple manner. But if you do something more complex, like payments or private DeFi, that's where complexity comes in and you have to properly handle this both on the client side and also on chain. Okay, so we covered state management. Now, what's left after that? So you have your business logic, okay? And business logic is kind of split again into two parts. So first is, what's, what is encoded in your ZK circuit? Again, circling back to the example with the ZK password. In your circuits, you would typically verify the signature that is produced by your chip, and, uh, you also extract some data and maybe, you know, uh, do some manipulation with that to, to, to produce the... To output the Boolean flag, let's say, okay? So this is the kind of private part. L- let's call it that way. O- on chain, and so your business logic would include, um, after you verify the proof and you're convinced that it i- it is correct, you would extract the, uh, public outputs, which will be typically, uh, like a Boolean flag, let's say, if you are over 18 or under 18. Use that plus maybe some like extra information that is passed along in a transaction, uh, for instance, your signature or your wallet address to let's say add some information to the map that can be later accessed to check if this particular wallet is authorized to participate in the, uh, you know, in the- in the token sale. So this is the- the part of the business logic that lives on chain. So when you, uh, kind of think about your pri- like, privacy-preserving application as a whole, you have to understand that this, this business logic is, like, somewhat split into, into two parts. Right. So on this diagram is like essentially a summary of wha- what I just said, right? So we have two parts of your application. On the client side you have your circuits, you have a prover, an executor and prover that's, uh, generates the proof. Uh, you could optionally have state-related components that are responsible for, uh, encryption keys and the, uh, state indexing. Now, on the on-chain side you have a smart contract that contains the proof verification logic, also business logic that is executed on top of that, and you also have some state management stuff like either state commitments and optionally encrypted states if you need that. Okay, let's move on. So what tools are we going to use to write those apps? We're going to use two languages, and Noir is the language we're going to use to write the ZK circuits. So this is part of the privacy-preserving application that we execute on the client, which means either in the browser or in the mobile application, maybe on your desktop, but not on the s- like, on the remote server, right? So it has to happen, uh, on the client so that the private information doesn't leak. So what is Noir? Noir is a domain-specific language designed specifically for writing zero-knowledge programs or circuits, if you may. What is cool about, about Noir, so first and foremost, it has a convenient Rust-like syntax, so if you know Rust, you will probably be more, like, comfortable with Noir, except for some extra domain knowledge that you have to acquire. And, uh, yeah, and package management is also similar to, uh, to Cargo. Under the hoods, Noir programs are compiled down to a spec-, uh, um, special internal representation which is called, uh, 

ACIR. It's quite cool because it, it allows multiple proven backends. What it means is that, uh, so by default we are using the proven backend, uh, developed by Aztec Labs. It's called Brandenburg. And this is the, the proven backend that- that is used by Aztec Network. Uh, but there are, there are other networks. So for instance, there is one, uh, backend de- uh, developed by, uh, Worldcoin for their client side proving. And, uh, I think a couple of more, uh, that are more experimental. Okay, so this is Noir. Now, when we're, where we come into the on-chain part, we are going to use Cairo language, and this is the language that I use to create smart contracts on StarkNet and StarkNet upchains. And again, so this is a Rust-like language with some specific things, but mostly it fails and you can write it as Rust. Interesting facts about Cairo is that it's actually generic language. Even though there is a, um... It's smart contract first and there is a really rich framework for writing smart contracts. You can use it to write any programs with the, uh, extra power that you can generate proof on them, right? So we'd see general language for writing provable programs. Also, Cairo is used both for smart contracts and for the program that executes those contracts. We call this program StarkNet Operating System. Yeah, so finally, Cairo is really tied to the Stark, uh, proven system. So this is the proven system invented and created within StarkWare. So it's heavily optimized for Starks and works best with them. Now, Noir applications on StarkNet. So, why Noir and why StarkNet? So when we talk about Noir, the first thing that comes to mind is that this is probably now the best development tooling to create ZK circuits, right? So even though probably the dominating tooling that is used in production these days is Circom with the Groth16 proven backend. So Noir is rapidly conquering this, uh, this industry and, well, just because it's a, it's a superior tooling with better developer experience. Uh, it comes with really, really fast client side proving, still small proof size, slightly larger than Groth16, but still.... but more important- importantly, compared to growth is impro- uh, proving, Noir, I'm talking about Bread and Berry backend specifically, does not require pair circuit trusted setup. If you don't know, uh, what, what is trusted setup is, in short, this is a specific ceremony that you have to do, uh, in order to make your verifier work. And, um, before, you had to do this for every new version of your circuits. You can imagine, right? So if you wanted to, you know, introduce upgrades to your apps, every time you have to do the ceremony, which takes time and also, you know, you have to gather a lot of participants and so on and so on. In case of Noir, now we can work with the universal trusted setup, which was done once, and now everyone can reuse it. That is pretty cool. Okay, now why StarkNet? Well, first of all, it settles on Zcash, right? And, uh, this, now this entire stack enables, um, programmable privacy. So you have the 

private shielding layer that keeps your funds, um, safe and, uh, 

private. And then on top of StarkNet you have, well, StarkNet provides, provides you scale and programmability and, uh, when you build with Noir on StarkNet, you essentially introduce programmable privacy on top of StarkNet, which means on top of Zcash, right? So it's the, uh, the end game. What StarkNet provides, it provides really low transaction fees and, um, really, uh, performance, uh, proving and aggregation rates. It also comes with native account abstractions. So this is the essential feature of StarkNet and the StarkNet up-chains. And when speaking about Noir specifically, we have a really cool piece of engineering called Garaga, which most importantly allows super cheap proof verification inside Cairo. So this is the kind of deal maker. So this is what allows us to run privacy preserving apps on StarkNet and StarkNet chains at a really, really low cost. I mean, for the user, right? So it's still sub, uh, um, so transactions, transactions, the calls of your private application costs a couple of cents. 

Okay, finally, what is Garaga? Just quick overview. Garaga is three things in one. First of all, it's a tool that can allow you to automatically generate Cairo contracts for verifying proofs just based on your circuit, okay? So you don't have to code anything yourself, you just call a single command and it will produce a fully-fledged smart contract that you can deploy right away. So secondly, it provides you an SDK for generating smart contract calldata, and you can do this in Rust, in Python, and TypeScript. Eh, lastly, this is just the efficient Cairo library that you can use for elliptic curve operations, for several signature schemes, for pairings and so on. So schematically, so it works like this. All right? So you have your Noir program, okay? You have your circuits that you, uh, compile down to the, um, intermediary representation. Now, the result of, of, of this compilation, uh, is passed to the code generation tool that outputs the Cabri code that you can deploy on Sta- on the StarkNet, uh, up-chain, and, uh, it results in a smart contract that lives now on the chain that, that's in its turn depends on Garaga as a library. On the other hand, if you wanted to interact with this contract, you take again your program and inputs, and you use Noir tooling to execute the program to produce the witness. Then you take the witness and again the program, and you take the backend to produce the proof, which then you, you submit to the Garaga SDKs to produce the calldata that later you use to invoke the contract to verify the proof. This is the pipeline, okay? So I think it's time for us to move to the hands-on part, and we're gonna to see how we can, you know, create an accounts, create our circuits, generate the verifier contract, deploy that, and then invoke on chain and even create a simple front end that does that, generate during the proof in the browser and then submit on chain. So this is the repo that contains all the code and instruction. So please scan the QR codes or paste the link. We will also share the link and all the materials after the recording. Uh, and right, so here is the repo where I have a quick start tutorial and all the accompanying codes. Within the repo you will find three folders, so do not enter the admin folder. So this is just for administrators. Uh, we have three parts. We have the circuits, we have the verifier contract and we have the front end application. And there's also Makefile that contains some useful comments and, uh, all the steps and instructions you can find in the README file. All right, so I will just quickly go over the, the components to, to show you what's inside. So in the second folder, we have a simple Noir program. It does pretty much nothing. It just has two inputs, one of them is private, another one is public, and we check that one of the inputs is not equal to the other one. All right? The verifier is the smart contracts that I already generated using Garaga. It's pretty huge, don't be afraid. And conceptually it's, it's somewhat simple, it just has these single methods that verifies the proof that you provide and it outputs the public inputs if there are any in case the, um, proof is correct. Otherwise you will get none here, okay? And lastly, the app itself is just a single page application-... uh, that generates the witness, generate the proof, and then invokes the co- the, the contract, so it calls this method, providing the encoded proof to check if everything is correct. Right, yeah. 

And also, verifi- verify contracts here is, is, is... It, it just looks quite complex but in the way that you've explained it, it's essentially just, you have your newer contract, you just pass it through the Garaga library and then you hit a few commands and then you get the verified contracts generated through Ga- through the Garaga itself, right? 

Yeah, exactly, exactly. 

Yeah. 

So, the cool thing about Garaga is that it kind of hides all the complexity for you, so you don't have to think about this. 

Yeah. 

Right. So, before we begin, so there are sever- several... There is some tooling that we have to install, first of all, uh, in order to both work with Neura programs and with Kyro programs. So for Neura, you have to check the, um, the make comments. So, there is a comment for installing Neura and also the Buretenberg backend. There are also instructions in the readme that tell you to do so. Yeah, here they are. For Kyro, we will need two things. So, we will need Scarp. Scarp is basically, uh, an analog of Cargo in Kyro wor- world, and the, the most convenient way to install is using the ISDF distribution tooling. And secondly, so we will need Starknet Foundry, so it's a bunch of useful tooling for interacting with the contracts, for deploying, et cetera. Uh, there are also... So we can just go, um, you can follow the links and follow the instructions for installation there. So, once you have all the binaries installed, luckily, we will need to create an account in Starknet. As I said before, Starknet is a Starknet op chain. In order to interact with it, you would need an account with some money on it. So, I already mentioned that, on Starknet we have native account abstraction. What this means is that unlike Ethereum, where you have the, uh, key, a key pair, which kind of defines an account that, that you own, on Starknet you have to explicitly deploy a contract that will be your account. So, this is a little involved. I prepared, uh, convenient aliases that you can just run, uh, so that you, you don't have to go into details. Basically, first we start with creating an account. What does it mean to create an account? So it means that we create a key pair that will control our account contract, and if you check, like, what this, what this command does, is that- is we invoke the foundry binary that we installed before. Um, so we say that we are g- we wanted to, to, to create a new account with a certain type from a certain program, so the class cache just basically says that we want to instantiate a new contract from, from, from this template. And, yeah, we're gonna... So this is the, uh, URL for the RPC where our chain runs. This is the default account name. So, I used Starknet. If, if you'd like, you can ch- you can change it. Know that there is also this foundry, uh, uh, file, configuration file that specifies the RPC URL and also the default account that is used every time you work with the smcast binary. So, once you have your account created, nothing happens at this point. So, next step is you need to send some funds to the address that is generated. So, the result of this command is that you will see in your terminal a, um... Let me show you, actually. You will see in your terminal the new account address that is generated based on your request. Okay? 

Just like you mentioned in the slides, whatever is being built here is just basically compatible with Starknet as well and it's just an RPC change at the end of the day, right? Uh, just building on Starknet, you just put a Starknet RPC and if you want to build on zStarknet, you just put the Madara zStarknet RPC and that's pretty much it. 

Yep, yep, yeah. That's right. Okay, so I already have such an account, so I'll just like change the name to show you how it looks like. Okay, so this is wha- what, what you will see. You will see that it resulted with success, and this is the address which is the address of your account, okay? And so we can already see that, that the smcast says, uh, account created, but it needs to be deployed. Uh, this is the estimated fee, uh, and, um, yeah, essentially you have to pre-fund your account. So, what do we do in order to pre-fund your account? We will use the, uh, Faucet. All right? Uh, okay. Let me show you how it looks like. Right. So, we're gonna use the Faucet. This is the Faucet, so you pass your address here and, yeah, it will send funds to this address and once it's done you can try to deploy your account. There's also an explorer, uh, for the Starknet you can use to check the status of, of your transaction and troubleshoot if e- everything goes wrong. So, we can see that... Yeah, so here's the pre-fund transaction, successful. So, thi- this is the explorer. Okay? Again, I will share all the links for the Faucet, for the explorer, for everything afterwards, so don't worry about that. Right, so it says that, yeah, I got the, the money and, uh, yeah, everything should be, should be fine. Okay? So now, when I, when I have my account created, uh, and there are some funds on this address, I can actually deploy the account. For that, there is a... Yeah, so there's an alias that does that. Okay, you just type "make account deploy" and we'll do all the work. So afterwards, you can ensure that everything is done correctly and you check what's your current account balance.Right? So, this is the preliminary states, uh, steps just to set, uh, set yourself ready. So at this point, we have all the binaries installed. We have accounts with some money on it, and we're ready to move on to building the application. First of all, the circuit, right? So, this is what- what we already done, so we need to install the Noir compiler and also the Brandenburg proven backend. We also need to install Garaga. So note that we will use Python, and, uh, Python can be tricky especially if- if you are on, depending on which operating system you are on. So I really recommend you to use Pyenv to manage your Python versions. Now, note for Garaga, we need a specific Python version, 3.10. So, on other versions it might not work correctly. So yeah, please be careful here. Once this is done, we, um, yeah, so here are the steps that cover the creation of the new Noir project. So, there is the, uh, scaffolding comment and, um, we'll need to create some files inside our project in order to, uh, execute the- the program and then generate the proof. So I won't go, uh, I won't, I won't do this right now to save time, so y- you can try it yourself. The, for, uh, generating the proof, there is a comment that, uh, says 

we're going to, that it uses the, uh, this specific scheme, okay? So we're using UltraHonk variants of the proven system. We are, yeah, we- we add in zero knowledge which means that our proofs do not leak any information about the private inputs. And we also s- say here that we are using StarkNet Oracle Hash. What it means is that now we use a specific flavor of the UltraHonk pro- uh, proven system that is optimized for StarkNet. So it allows us to ver- th- this is like one of the things that allows us to verify Noir proofs really cheaply on StarkNet. So, this is what we need to do to generate the proof. And then there's also a comment that allows you to produce a very fine key. Very fine key is an important thing. This is what is used to be, uh, automatically generate the verifier contract. This is also used on the client where you execute the program. Now, once you have those two things down, we move onto the next step which is, uh, generating the verifier contracts from your circuits using Garaga and its code generation feature. So again, with Gar- in Garaga, we specify the pro- the pre- the specific flavor of the proven system that we use. Remember that we're using UltraHonk, and the StarkNet Oracle Hash and Wiz DK. So, it's all combined in this system parameter. And we also provide the path to the verification key that we have generated previously. And, uh, yeah, I named the project Verifier. You can use whatever, any name you'd like. The result of- of this comment is that you will, you will get all these files automatically generated. So, all the Cairo source codes, and also the Scarp manifest, the two versions file, like everything. So afterwards, you can just go to building the contracts right away. And this is just simply Scarp build. As a result, you will get the executable for your- for your smart contract that we can later deploy. All right, so here, important note on deploying contracts on StarkNet. So you might remember that I mentioned the, such a thing as the class hash. So on StarkNet, deployment is typically done in- in two steps. So first, you upload the codes to the network. So this operation is called declaration where you need to declare the contract, okay? And this is what we're going to do using, again, the sncast binary. There is a nice comment that is called declare which accepts the single parameter contract name, uh, and this is the same name that we have in the co- sorry, in the codes, if you check the smart contract. So this is the ultra-starknet-zk-honk-verifier module that we wanted to declare. Okay? So we're done with declaration. As a result, in the terminal you will see that the contract has- has been declared successfully. This is the class hash. And now you're going to use this class hash in order to deploy your contract. Okay, so here's the first kind of friction point that is not, that is, um, s- s- kind of specific to StarkNet, so you will not face it on the, uh, on the canonical StarkNet. The deployment is done not through, um, you know, convenient alias like declare we had with sncas. So here, we have to call another contract that will do the deployments on our behalf. Okay? So this is, this is a little bit weird, and, uh, looks like an overhead, but it's kind of the way things are done. So it's an indirection that allows you to deploy a contract through a means of calling other contract which is called universal deployer, if which makes sense. And what we do here is we invoke this deployer contract, right? We specify the address. So this is the kind of publicly known address that is used by everyone. So we say that we wanted to invoke the method called deploy contract. Makes sense. And we also pass the calldata. So the calldata, in our case, is class hash, okay? And for the Noir verifier contract, so there are no constructor parameters, okay? So if we check the, if we check the Cairo code for the HonkVerifier, we will see that, yeah, so there is, like, no constructor, okay?... which means that we can just deploy the, the, this contract without passing any additional data, and, uh, that's why we have all the zeros here. O- like, otherwise, we would have to specify the contract constructor arguments here. You do that, and as a result, you will see that there's a successful operation in the, in the explorer. In the transaction details, you, you will see that there's an advanced contract deploy, uh, deployed, and the results and address where y- your contract lives now. So, great. We're at the stage where we have our verifier contract deployed, which means that now we can actually verify the proof on Starknet. So, what do we have to do for that? 

Michael, uh, I'm sorry, Michael, j- just a quick note here. Since the con- the verifier contract does not have any, uh, constructor parameters or doesn't have any constructor itself, right, then w- why, why are we exactly passing, like, three arguments over there, uh, for the call data? Like- 

No, because- 

Because- 

There are some, like, arguments that you have to pass. S- some service, service arguments, uh, I think this is the salt. It's responsible for generating, uh, deterministic or, or, you know, so that the address of, of your contract is deterministic. And if I remember correctly, so the last one is the length of the call data, right? So, the length of the, of the constructor call data, so I set it to zero because we have no constructor arguments. And there was something else. Honestly, I can't remember. So, it might be- 

Right 

... uh, nonce, nonce or something. 

Because usually we just do sn-cast deploy and then we just pass in the contract and, uh- 

Yeah 

... if there's no constructor, we just leave it. 

Yeah, exactly. O- o- on Starknet, so, w- we typically use universal deployer contract, the second version, which is what sn-cast and other tooling kinda work with. I think there are actually now, there is a universal deployer version too, but I, I, I haven't tried it yet, so maybe you can actually already use sn-cast deploy here. 

Got it, got it. 

But this approach would also work. Anyways, so we have the verifier deployed. Now we can verify the proof, but if you remember from the, from the chart, 

in order... First of all, we have to encode the proof in the way that Garaga, a verifier contract, would understand. And for this, we will use the Garaga tooling again. There is a convenient command called garaga-calldata that would convert the proof from the binary format to the, uh, call data 

that, uh, a Garaga contract would understand. Again, so we specify what is the exact proving system flavor we're going to use. We specify the path to the proof, the path to the verification key. Uh, we also have to provide the public inputs. And in the result, we will get the, uh, so... You, you, you will check it so it's a, uh, list of field elements that will be passed to the, um, verification method. All right? Once we have the call data, we, again, so we will call the contract. So now, the contract is the verifier smart contract that we deployed previously, right? And we say we g- we want it to invoke the ver- verify methods and the call data will be as follows. Note that there is a difference between calling a contract and invoking a contract. When you do sn-cast.call, you do not create any on-chain transaction. So, this is quite useful because if you wanted to just test something or, you know, there are scenarios wh- wh- when this is sufficient. But if you wanted to actually create a transaction, an on-chain footprint and, you know, see what is the, what is the gas consumption, you know, compose that with other contracts, you use invoke. And, uh, yeah, you can see that the signatures are pretty much the same, just the, uh, the methods are, are, are different, different here. All right. Uh, so lastly, so, so far we have been executing and producing proofs for our circuits using the binaries in our terminal. Now, if we wanted to build something that looks more like an application that you can ship to your users, we need a front end and we also need to generate proofs in the browser. Okay? And in order to showcase that, I added a single, single, simple... Sorry. All the code is already there. All you need to do is to install, again, some extra dependencies. We will need Bun to install JavaScript dependencies and run the, um, the application locally. Also, you would need to copy some artifacts to the apps folder. It's... Like, again, it's the verification key, it's the circuit itself, and also the verification contract. Those are the, some, like, artifacts that you just need to copy once and then they will be embedded in the static resources into the application for all subsequent, uh, invocations. So, once you've done that, you can run the application. Uh, I'm just, I'm going to show you how it looks like. Yep. Okay. So, here's the app. It's very simple. Uh, if you remember previous slideshow, I've shown that I have the simple circuits with two inputs. This is the... One of them is... So, here is the private one, this is the public one, and the goal is to prove that those two inputs are not equal. And for demo purposes, I have these stages that show where are we at the, uh, this particular moment of time. So, the first step is to execute in the program to generate the witness, then we produce the proof, then we encode the proof into the format that is, that the smart contract would understand. Then... Okay, so this step we skip. We do not need to connect the wallet for now. So, finally, we will invoke the contract. Okay? So, this is a bit incorrect, so we, we are not actually sending transactions, so we just...... we just call the contract without creating tran- on-chain transaction just to see that the, the proof is, is, is verified correctly. All right. Yeah, we'll just open the consult to, to show you something. 

All right. 

Okay. Witnesses is, is created. Proof is generated, encoded, and the contract is invoked. So, here is the, the response. The response is 10, so 10 is basically the pub- the public input. So, remember, yeah, so that's, that's basically the, the response from, from the RPC. And so, the, the result of the invocation of our verifier conflict on chain is sum. And if you remember, sum means that we... Yeah, the proof, the proof i- is verified correctly, and then we get the list of the, uh, public outputs, and our public outputs is 10. And that's what we see here. Okay. So, again, so this is very basic app. It just shows what you can do. Then you just add your business logic on top. You add your state management, whether it's commitments that you store on chain or some data that, that is encrypted on the client and then stored on chain, and so on and so on. Yeah, I guess that, that's pretty much it. So, again, we will share all the links and materials with you after, after the presentation. Please feel free to reach out in our Telegram chat if you have any questions about Gareca or Noir or Cairo, or just general StarkNet development. So, we'll be happy to help. And, uh, yeah, I guess happy hacking. 

Yeah. Thank you so much, Michael. And, uh, I think this could be a really, uh, good starting point for all the devs, uh, who are looking to leverage or start building on StarkNet. I think they could just, uh, you know, start forking, uh, the quick start repo that Michael has here, and they could start this, uh, start writing their whole application just u- leveraging this. Uh, yeah, thank you so much, Michael. But also just before we end, uh, I just have a couple of questions as well. Uh, okay, so since we have the StarkNet or StarkNet right now live, and this is on testnet, right? And what exactly does this mean to the Zcash community, and how far is this from being possible on actually becoming the actual roll-up on top of Zcash, and what's, what's like, the communities? How's the community feeling right now? 

Yeah, that's a great question. Basically, the, the, the current state is that, uh, we are at the, in the exploration phase. We have several proposals which you can find, uh, in the, um ... on the Zcash forum if you're in- 

Yeah 

... interested. Uh, it... Essentially, we have two. So, the first proposal is to introduce 

the, uh, 

Stark TDE. So, it's a new Zcash transparent extension that is capable of verifying Stark proofs, and also carrying the state over an L2. 

Okay? Obviously, so it also depends on the, um, decision whether the mechanism of the extension itself will be adopted and, uh, enabled in the, in the Zcash protocol. We are also d- We are, uh, d- dependent on that. On top of the Stark TDE, we also have a proposal for a StarkNet layer two. So, why is it the separate proposal? Because, uh, for... If we're talking about the, the transparency cash extension, it's kind of hard to make it, make it generic. So, we still have to introduce some notion of the L2 state in order to properly implement deposits and withdrawals, and also longer term DA, uh, commitments, things like that. And therefore, yeah, so our, our proposed solution is to, in some sense, en- en- enshrine a, a notion of a stark- of a StarkNet L2 in, in this specific TDE. And basically, in this proposal, we argue why StarkNets is the, um, the good c- good choice for scaling Zcash, right? Because it's a battle-tested Stark technology, and also involves a vibrant community of developers, and the, uh, established ecosystem of tooling and so on, so on, so on. So, that's what this proposal is about. And, uh, yeah, so we are quite happy about those two proposals because there is a lot of feedback both from the core team and from the community members, and this 

Mm-hmm. 

There was a constructive d- discussion. There are really, really good points, I mean, counterpoints, like why is this might be not a good idea. For instance, because Stark proofs are huge, and also enshrining a specific proving system might be not a good idea, things like that. 

Makes sense. 

But we're, we're working with that. So, I'm, I think there will, will be some progress in the coming month. 

Got it. 

But nevertheless, so StarkNet is kind of a parallel effort to showcase how the solution could look like. And we are very happy that many teams want to be part o- of the, of, of this effort to provide either infrastructure or faucets and explorers and sequencers and provers, and also builds on top of StarkNet. So, it's quite exciting. 

Sounds good. Uh, I've got a tricky question. 

Yeah, yeah. Sure. 

I mean, feel free to skip as well. But what do you think goes through... What, what do you think would go through first? Do you think it's OPRCAT or the opSTARK-verify passing through, uh, on the Bitcoin side first, or is this, this teasy, uh, going through first? What do you think? [laughs] 

Yeah. I mean, that's a good question. I mean, I think, like, first of, like, both options. It's... Well, first of all, like, the probability that's, uh, 

you know, either of the proposals will, will be accepted by Zcash community is much, much higher than, than anything could be accepted by Bitcoin community because Zcash community is smaller. It's moving at the, uh, faster pace and it's not that ossified yet, uh, thankfully, compared to Bitcoin. So here, there are more cha- more chances. But at the same time, there are a couple of really large projects ongoing in the Zcash right now. It's Cross-Link hybrid proof-of-work, proof-of-stake on, on the one hand, and it's also Tachyon, uh, scaling effort on the other hand. And the chances that anything else would be incorporated to the protocol before those two-... are pretty low, in my opinion. Uh- 

Got it. Makes sense. And also, since this is like a chain on top of Zcash, so this essentially would lo-, uh, you know, allow us in having canonical bridges, canonical trustless bridges, if I'm not wrong? 

Yeah. Yeah, you're right. 

How would this... So how would this benefit Starknet, or how, how is this gonna be? Like, I, I know this is a POC and this is something that's still in, under exploration, but I'm just trying to understand how the, how the roadmap look like for this. For example, would this be something like, say something like, being able to settle at the same time both on Zcash and b- and both on Ethereum? And maybe again, a possibility of having, like, I don't know, trustless, trustless bridges directly from Starknet to Zcash? Is that something possible, a z-Starknet? Or how is this supposed to go? 

Yeah, of course. I mean, obviously so everything related to interop will be made much simpler, right? Because now you have e. Like, especially if, you know, if what I mentioned before, the cross-link is activated, we could have a really trust-minimized bridges between Zcash and other chains. But the... Okay, so obviously s- so there can be many, many use cases, many things we can build on, on top of this stack. So the one that we were particularly excited and the one we envision is the actually an application-specific chain running on top of Zcash, which does one thing good. So it can be a perpel- perpetual DEX, for instance, that is ideally also provides some sort of shielding for 

traders, 

traders and also for assets. So that would be quite cool application that you can build on top of this stack. This would also be other DeFi primitive or maybe some payment solution and so on and so on. So the best thing about Emon, you can run as, as many such applications as, as, as, as you want, because it's a... You know, j- you have a mechanism for spinning kinda native scaling solutions on Zcash, and you can do with this, like, what you want. 

Makes sense. Yeah, I mean, uh, since you also touched upon the option for app-specific, uh, app, like the more on the option part, for example, just like you mentioned, the Perpex on, uh, on top of Zcash itself. Since we've, we've r- like, very focused towards z-Starknet, like, I wanna also understand, like, what particular a- dApps or zApps, because since we are building on z-Starknet, what, w- what's those zApps that you're really looking forward to being built on this, for this particular hackathon? 

Yeah. That's, that's, that's a great question. So, well, I think first of all, well, even, like, aside from the pri- privacy-preserving apps, we would be happy to see any apps, like, running on Starknet. So as many, as many apps that, that, t- t- t- uh, that we can bring on, just to, you know, create a small, like, ecosystem that will showcase the power of the Starknet, and also, you know, like, fill the blocks, so we know if our proving pipeline, uh, works great- 

Okay 

... or not great. Now, if we're talking about privacy apps in particular, because there's actually the most interest from the community when we talked about those proposals, were about kind of 

pr- uh, stack that is private end-to-end, right? So a lot of people expressed concerns about, like, totally validated apps. There's no, not much value in the, uh, transparent applications on top of the Starknet, on top of Zcash, if, like, if we do things properly, so the entire stack has to be fully shielded, okay? 

Yep. 

So therefore, therefore, the focus on, on the privacy-preserving application of the Starknet and this tutorial, okay? Now, the application that we would love to see, like again, so anything. So the l- the, the only limit is, is your imagination. But of course, it's... I mean, it can be something with, with payments. It can be something with private swaps. It can be something with the identity, with shielding, shielded trading strategies. It can utilize not only NOIR, but maybe a core NOIR with collaborative Starks and private shared state. I mean, it's a bit tricky, because it, it requires kind of further integration with, with the MPC network. But still, you can, at least you can do some POCs, and they should work. There are also interesting ideas in how you can create cross-chain bolts. In particular, like how can you, let's say, keep your money shielded on Starknet, and then use this money as a collateral for a DeFi, let's say, that is running on Starknet or on other, other chains. Okay, so that may, might be quite interesting, because like imagine if you, like, you don't have to bring a pair of decks to Starknet. Let's say Extended, but instead, you just have your collater- you have your deposits made on Starknet, and then you use that to trade on Extended on the canonical Starknets. So that would be quite cool. 

That makes sense. 

Yeah. So this is one of exactly ... one of the examples of interop-related applications. So of course, everything related to bridging, atomic swaps, privacy-preserving atomic swaps, which is kinda separate beast. And, uh, yeah. I mean, it can be anything. [laughs] 

And also like, um, the one more thing is that because since everything is, you know, cross-compatible, essentially like whatever's, whatever adapts that's available on Starknet can also be deployed on top of Starknet. So of course the contracts for, uh, the perpetual protocol, for example, Extended, and we also have the, uh, the exploration project called Satoru, which is basically the GMX V2. I think probably, you know, people could just leverage that, and I don't know, probably do something with NOIR contracts over there. And again, probably with, with respect to Dex, again, it could go the best, best Dex on Starknet. Their contracts are also open sourced, and probably since most of the stuffs are already done, probably the teams can just focus on the privacy-preserving part. So that's with respect to Dex and then Perpex 

full protocols. And then finally, of course, for lending and borrowing, ves- Vesu contracts are also open sourced. 

So people can send just leverage those and just focus on the main part, which is basically the privacy preserving. And, uh, yeah, I think it'll be super cool to see, uh, those deployed on the z-Starknet or Starknet, as you mentioned. 

Yeah, absolutely. 

Yeah. 

This is- 

Uh, and yeah. Uh, I think that's pretty much it. But Michael, any final notes before we end the, end the, uh, workshop? 

I mean, I wish you all the best luck, and, uh, most importantly, have fun. Uh, yeah, again, so do not hesitate to, to reach out if you have any issues. Yeah. 

Yep. 

We'll, we'll, we're happy to help. 

Sure. Thank you so much, Michael. And, uh, just, just- 

Thank you 

... before we end, we also, we will also be putting all the links in the, uh, in the next tweet, uh, with all the Telegram chats, with all the RFPs, with respect to all the tracks that we have. And we did, we did start putting the tracks, but also we also put relevant RFPs so that people can just, or teams can just focus on building that particular dApp. Uh, yeah, and it's just how things could go through. So yeah, everything would be in the next tweet. Really excited for what you guys have been building. And, uh, thank you, Michael, again, uh, for joining us. And, uh, until then, let's see you on the next one. Yeah. Thank you so much. 

My pleasure. Thank you. 

Thank you. Bye-bye. 

Bye-bye. Take care.